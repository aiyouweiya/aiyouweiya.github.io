<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[开始Hexo搭建博客（一）]]></title>
      <url>%2F2017%2F02%2F15%2F%E5%BC%80%E5%A7%8BHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdwon（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 —— 文档 | Hexo —— 环境准备安装Git 有梯子：https://git-scm.com/download/win 无梯子: https://github.com/waylau/git-for-win 一路下一步安装，安装完成需要做一下简单的配置，在任意位置右键鼠标，你会发现条目中多出几个与Git相关的条目。其中Git Bash Here使用最为普遍，他提供一种类似Linux Shell的风格。 安装Node.jsNode.js: https://nodejs.org/en/ 也是一路下一步安装，注意请勾选Add to PATH选项。 安装Hexo在任意位置右键，选择Git Bash Here，执行$ npm install -g hexo-cli进行安装，安装过程可能会比较慢，请耐心等待。 开始搭建初始化安装Hexo完成后，选定一个目录作为你的博客根目录，然后在该目录下右键点击Git Bash Here，Hexo将会在指定文件夹中新建所需要的文件。 12$ hexo init # 初始化工作目录$ npm install 完成该操作后，你会发现指定目录的目录结构变成如下： 12345678.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。├── package.json # 应用程序的信息, 记录了程序的名称、版本、依赖等。├── scaffolds # 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source # 资源文件夹是存放用户资源的地方| ├── _drafts| └── _posts└── themes # 主题文件夹。Hexo 会根据主题来生成静态页面。 生成静态页面打开source\post文件夹，里边有一篇测试文章hello-world.md，然后我们回到Git Bash执行hexo generate命令，完成后你会发现根目录下多出一个public的文件夹，里边就是根据post里面的文章生成的静态文件。 本地预览执行如下命令，启动本地服务，进行文章预览调试。 1hexo server # 启动本地服务器 浏览器输入http://127.0.0.1:4000就可以看到一下效果。（亲测，不要使用微软家的浏览器）。预览完毕后Ctrl+C关闭服务器。 你的第一篇博客既然框架已经搭建好了，那我们现在就来开始创作自己的第一篇博客吧！！！ 选择编辑工具那么首先我们应该选择一款心仪的编辑工具来编写博客了，下面是比较知名的几款编辑工具： 在线编辑 MaHua：http://mahua.jser.me/) 简书： http://www.jianshu.com/ Cmd Markdown 在线版 https://www.zybuluo.com/mdeditor 本地编辑 Typora: https://typora.io/ Cmd Markdown 客户端 https://www.zybuluo.com/cmd/ 马克飞象: https://pan.baidu.com/s/1sl7tx29#list/path=%2F （收费的） 这几款编辑器都各有各的优缺点吧，有实用的，有耐看的，有Geek的，孰优孰略大家可以都尝试看看，我自己使用的是Typora。 开始写作用编辑器打开source\post\hello-world.md，有可能你看不懂，这是用Markdown语法写的文章，不过现在不用懂语法，我们就模仿这个文件自己写一个出来试试看。 编辑你的博客内容如下： 1234---title: Hello,Hexo---Hello,Hexo !!! 然后保存，记住要保存到post目录下，接下来就要开始生成静态页面了，回到刚刚的根目录，右键Git Bash Here 。 123hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo generate #生成静态文件hexo server #开启服务器 浏览器输入http://127.0.0.1:4000就可以看到一下效果。（亲测，不要使用微软家的浏览器）。预览完毕后Ctrl+C关闭服务器。 部署到Github以上过程就是本地编辑、预览的全部过程了，接下来我们要将文章托管到Github上，以供其他人可以访问。 注册Github账号在 https://github.com/ 注册你的账号，用户名和邮箱比较重要，想好了再填，其他的也没什么好说的，比较简单。 创建代码仓库第一次创建仓库时会要求你验证邮箱，去邮箱里面验证一下就好了。下面我们创建一个代码仓库作为博客的容器，仓库的名字必须是yourusername.github.io，创建完成后在浏览器敲入yourusername.github.io就可以看到效果，不过比较简陋，因为现在仓库还是空的。 配置Git12$ git config --global user.name &quot;Your Name&quot; # 刚刚注册的用户名$ git config --global user.email &quot;email@example.com&quot; # 刚刚注册的邮箱 生成密钥1234567$ ssh-keygen -t rsa -C &quot;email@example.com&quot; # 生成密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Documents and Settings/Administrator/.ssh/id_rsa): # 在此目录下保存密钥Enter passphrase (empty for no passphrase): # 读取密钥的密码（非常重要，设置时要小心）Enter same passphrase again:Your identification has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.Your public key has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.pub. 上述命令若执行成功，会在c/Documents and Settings/Administrator/.ssh/目录下生成两个文件id_rsa和id_rsa.pub，带pub的是公钥，另外一个是私钥。 添加私钥到ssh-agent确保ssh-agent是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 123$ eval &quot;$(ssh-agent -s)&quot;Agent pid 59566$ ssh-add ~/.ssh/id_rsa 上传公钥打开公钥，将里面的内容复制到剪切板，然后来到Github网站，点击你的头像，点击Settings ，点击 SSH and GPG keys，点击New SSH Key，粘贴剪切板内容。 安装hexo-deployer-git插件1$ npm install hexo-deployer-git --save 修改部署配置打开_config.yml，滑到最下面，修改以下内容。 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 修改为： 1234deploy: type: git repo: yourusername.github.io branch: master 开始部署回到根目录下，执行以下命令开始部署。此过程需要输入私钥的密码。 1hexo deploy 部署完毕，大概几十秒后在浏览器键入yourusername.github.io即可看到效果。以上就是写博客的大体步骤了。 总结本片博客主要介绍了Hexo搭建博客的过程，包括环境准备，搭建框架，创作博客，本地预览，部署到Github，这样的几个步骤。 最后的最后这几个命令要牢记，因为这几个命令就是大体的流程了。 1234hexo cleanhexo generatehexo serverhexo deploy 感谢量子广告: http://blog.ynxiu.com/2016/hexo-you-blog.html 西山雨: https://segmentfault.com/a/1190000002645623]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用WinSCP远程连接Linux主机的小技巧]]></title>
      <url>%2F2017%2F02%2F13%2F%E7%94%A8WinSCP%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E4%B8%BB%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[什么是WinSCPWinSCP是一个Windows环境下使用ssh的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件，提供图形化界面，操作起来十分简单方便。传送门 使用密钥登陆远程主机WinSCP默认使用密码登陆，这种方式当然，是不安全的，所以我们要设置成密钥登陆 点击登陆对话框的高级按钮，弹出高级站点设置对话框，SSH--验证--密钥文件，选中之前生成的密钥文件id_rsa即可，程序会自动转换为ppk格式。 做好上述配置后，退出链接，再次连接时会提示你输入密钥的密码。 与远程主机保持连接尽管这个软件使用起来特别方便，但是隔了几分钟没在上面操作，连接就会断开，我们可以通过小小的设置就可以解决这个问题，在登陆状态下菜单栏的选项--选项--面板--远程，勾选上刷新远程面板间隔即可。 直接用root账户登陆修改/etc/ssh/sshd_config，把PermitRootLogin prohibit-password改为yes 修改/etc/sudoers，注释掉ubuntu ALL=(ALL:ALL) NOPASSWD: ALL，并添加下面内容 12ubuntu ALL=NOPASSWD: ALL%sudo ALL=(ALL) NOPASSWD:ALL 修改WinSCP设置，高级--环境--SFTP，修改SFTP服务器为sudo /usr/lib/openssh/sftp-server，保存，之后登陆就不再需要切换到su下了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH远程登录Linux主机方法及原理]]></title>
      <url>%2F2017%2F01%2F03%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Linux%E4%B8%BB%E6%9C%BA%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[什么是SSHSecure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH是一项建立在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗,总之它能够为我们安全使用远程主机提供保障。 怎样使用SSH登陆在客户端来看，SSH提供两种级别的安全验证。 第一种级别（基于密码的安全验证），知道帐号和密码，就可以登录到远程主机，本地主机用服务器的公钥对密码加密，然后将加密后的数据发送到服务器，服务器使用私钥解密，密码验证成功则允许登陆，否则不允许登陆。 第二种级别（基于密钥的安全验证），需要依靠密钥，也就是你必须为自己创建一对密钥，并把公有密钥放在需要访问的服务器上。客户端软件会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在你在该服务器的用户根目录下寻找你的公有密钥，然后把它和你发送过来的公有密钥进行比较。如果两个密钥一致，服务器就用公有密钥加密「质询」（challenge）并把它发送给客户端软件，客户端用私钥进行解密，然后将解密后的数据发送回服务器进行验证。 密码登录假设你是第一次登录远程主机，使用$ ssh ubuntu@xxx.com登录，你会得到 123The authenticity of host &apos;123.206.198.83 (123.206.198.83)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:P0XOcgjXyTikxaGKzmWsALKUYZPqTftP0KTFoTJnFvs.Are you sure you want to continue connecting (yes/no)? 意思是：我是你要登陆的远程主机，我的公钥的SHA256指纹是P0XOcgjXyTikxaGKzmWsALKUYZPqTftP0KTFoTJnFvs,你是否要继续连接，此时该主机的公钥指纹是不可信任的（中间人攻击），我们可以将其与远程主机的公钥进行对比（一般是公开的）例如Github公钥https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/ 如果一致的话就可以确认链接，不是的话就说明存在中间人攻击了。 当确认连接后，会提示输入密码ubuntu@xxx.com&#39;s password:，此时输入正确的密码即可成功登陆，显示如下 12345678Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-53-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantageLast login: Mon Feb 13 14:32:03 2017ubuntu@VM-37-129-ubuntu:~$ 中间人攻击攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。下面这个例子解释了密码登陆的危险性。 假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截窃会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。 首先，爱丽丝会向鲍勃索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。1.爱丽丝发送给鲍伯一条消息，卻被马洛里截获： 2.马洛里将这条截获的消息转送给鲍伯；此时鲍伯並無法分辨这条消息是否从真的爱丽丝那里发来的： 3.鲍伯回应爱丽丝的消息，并附上了他的公钥： 4.马洛里用自己的密钥替换了消息中鲍伯的密钥，并将消息转发给爱丽丝，声称这是鲍伯的公钥： 5.爱丽丝用她以为是鲍伯的公钥加密了她的消息，以为只有鲍伯才能读到它： 6.然而，由于这个消息实际上是用马洛里的密钥加密的，所以马洛里可以解密它，阅读它，并在愿意的时候修改它。他使用鲍伯的密钥重新加密，并将重新加密后的消息转发给鲍伯： 7.鲍勃认为，这条消息是经由安全的传输通道从爱丽丝那里传来的。这个例子显示了爱丽丝和鲍伯需要某种方法来确定他们是真正拿到了属于对方的公钥，而不是拿到来自攻击者的公钥。 密钥登陆生成密钥首先设置你的用户名密码： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 然后生成密钥： 12345678$ ssh-keygenGeberating public/private rsa key pair.Enter file in which to save the key (/c/Documents and Settings/Administrator/.ssh/id_rsa):（设置保存公钥和私钥的位置，保持默认，可以不填直接回车）Enter passphrase (empty for no passphrase): （读取id_rsa的密码，可不填，不过建议填写）Enter same passphrase again: （再次输入id_rsa密码确认）Your identification has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.Your public key has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.pub.The key fingerprint is:生成的KEY 你的email帐户 完成以上就在c/Documents and Settings/Administrator/.ssh/生成了密钥对。 上传公钥接下来我们就要将公钥发送给服务器，这个过程需要你输入密码（在未登录的状态下执行以下命令）1scp ~/.ssh/id_rsa.pub ubuntu@xxx.com:~ 输入密码后，公钥就被发送到服务器，但是还没完，我们还要将公钥添加到authorized_keys中，才能让服务器识别出本地的主机.（要在root权限下执行，不会自行百度）12cd /home/ubuntucat id_rsa.pub &gt;&gt; .ssh/authorized_keys OK，该主机的公钥已经被服务器识别，当你再次$ ssh ubuntu@xxx.com时，你会得到：1Enter passphrase for key &apos;/c/Users/aiyouweiya/.ssh/id_rsa&apos;:（输入私钥的密码） 完成以上操作，就可完成密钥登陆。 禁用密码登录中间人攻击让密码登录变得不安全，因此我们需要在服务器设置禁止密码登陆，进入/etc/ssh目录，编辑sshd_config文件，设置此选项PasswordAuthentication no,即不允许密码登录，之后还要重新启动service restart sshd。 总结因为公钥加密比密码直接登录更安全，所以一般的服务器都会默认将PasswordAuthentication设置为no，即不允许密码登录。但是当你开启密码登录时，默认会先采用公钥登录，公钥登录不成功还是会采取密码登录。ps：本地密钥丢失也会直接采用密码登录。下面比较这两种登录方式的差异。 密码登录 公钥登录 含义 本地主机用远程主机的公钥对密码加密，远程主机私钥解密 远程主机随机发送字符串到客户端，客户端用私钥加密，发送回远程主机，远程主机用公钥解密 安全性 低，容易受到中间人攻击 高，但是要确保本地秘钥的安全性 本文都是在Ubuntu Server 16.04.1 LTS 64位下进行的操作，其他类型的Linux机子都大同小异，留待读者自行研究吧……]]></content>
    </entry>

    
  
  
</search>
